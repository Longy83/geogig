/* Copyright (c) 2017 Boundless and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/edl-v10.html
 *
 * Contributors:
 * Erik Merkle (Boundless) - initial implementation
 */
package org.locationtech.geogig.spring.controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpUtils;

import org.locationtech.geogig.rest.repository.RepositoryProvider;
import org.locationtech.geogig.spring.dto.LegacyResponse;
import org.locationtech.geogig.web.api.StreamingWriter;
import org.locationtech.geogig.web.api.StreamingWriterFactory;
import org.slf4j.Logger;
import org.springframework.http.MediaType;

import com.google.common.base.Optional;

/**
 * Base Controller to hold common controller logic.
 */
public abstract class AbstractController {

    /**
     * Request parameter for requesting API version 2 responses. This is currently not supported
     * and may or may not ever come to fruition. If a controller wishes to support API version 2, it
     * should produce responses generated by the Spring MVC framework MessgaeConverters for
     * XML (JAXB2) and JSON (Google's Gson) when this parameter is in the request.
     */
    protected static final String API_V2 = "api_version=2";

    /**
     * Extracts the {@link RepositoryProvider} from the HTTP request. The {@link RepositoryProvider}
     * should be injected at server startup.
     *
     * @param request The request from which a RepositoryProvider should be extracted.
     *
     * @return An {@link Optional} of the RepositoryProvider from the request.
     */
    protected final Optional<RepositoryProvider> getRepoProvider(final HttpServletRequest request) {
        Object providerValue = request.getAttribute(RepositoryProvider.KEY);
        if (providerValue != null &&
                RepositoryProvider.class.isAssignableFrom(providerValue.getClass())) {
            return Optional.of((RepositoryProvider) providerValue);
        }
        return Optional.absent();
    }

    /**
     * Encodes the Response directly to the HTTP OutputStream. This method is to provide a way to
     * reuse the old Restlet Representation stream writing within the Spring MVC framework so that
     * the response format of GeoGig Web API requests remains the same.
     *
     * @param responseBean An encapsulated response object that can write itself to a
     *                     {@link StreamingWriter}.
     * @param request      The Request that produced the supplied responseBean.
     * @param response     The Response to which the responseBean should be written.
     */
    protected final void encode(LegacyResponse responseBean, final HttpServletRequest request,
            final HttpServletResponse response) {
        // Extract the baseURL from the request (NOTE: not reliable if proxies are involved)
        final String baseURL = getBaseUrl(request);
        // determine requested output format
        final MediaType requestedResponseFormat = getMediaType(request);
        // set the Content-Type since we aren't using Spring's framework here
        response.setContentType(requestedResponseFormat.toString());
        // write the LegacyResponse object out to the Response stream
        try (StreamingWriter streamWriter =
                StreamingWriterFactory.getStreamWriter(requestedResponseFormat,
                        response.getWriter())) {
            streamWriter.writeStartDocument();
            responseBean.encode(streamWriter, requestedResponseFormat, baseURL);
            streamWriter.writeEndDocument();
        } catch (Exception ex) {
            getLogger().error("Error writing response", ex);
            throw new RuntimeException(ex);
        }
    }

    /**
     * Encodes the command Response directly to the HTTP OutputStream. This method is to provide a
     * way to reuse the old Restlet Representation stream writing within the Spring MVC framework so
     * that the response format of GeoGig Web API requests remains the same.
     *
     * @param success Whether or not the request was successful
     * @param responseBean An encapsulated response object that can write itself to a
     *        {@link StreamingWriter}.
     * @param request The Request that produced the supplied responseBean.
     * @param response The Response to which the responseBean should be written.
     */
    protected final void encodeCommandResponse(boolean success, LegacyResponse responseBean,
            final HttpServletRequest request, final HttpServletResponse response) {
        // Extract the baseURL from the request (NOTE: not reliable if proxies are involved)
        final String baseURL = getBaseUrl(request);
        // determine requested output format
        final MediaType requestedResponseFormat = getMediaType(request);
        // set the Content-Type since we aren't using Spring's framework here
        response.setContentType(requestedResponseFormat.toString());
        // write the LegacyResponse object out to the Response stream
        try (StreamingWriter streamWriter = StreamingWriterFactory
                .getStreamWriter(requestedResponseFormat, response.getWriter())) {
            streamWriter.writeStartDocument();
            streamWriter.writeStartElement("response");
            streamWriter.writeElement("success", Boolean.toString(success));
            responseBean.encode(streamWriter, requestedResponseFormat, baseURL);
            streamWriter.writeEndElement();
            streamWriter.writeEndDocument();
        } catch (Exception ex) {
            getLogger().error("Error writing response", ex);
            throw new RuntimeException(ex);
        }
    }

    /**
     * Extracts the desired Response format from the Request. The default response format is XML.
     * The GeoGig Web API only supports XML and JSON responses (for requests that don't produce a
     * file output), therefore the returned format will be XML, unless the Request URI specifies
     * ".json" at the end, in which case, JSON would be the response format.
     *
     * @param request The Request from which to determine the desired Response format.
     *
     * @return A {@link MediaType} representation of the desired Response format, either
     *         {@link MediaType.APPLICATION_JSON} or {@link MediaType.APPLICATION_XML}.
     */
    protected final MediaType getMediaType(HttpServletRequest request) {
        final String requestURI = request.getRequestURI();
        if (requestURI != null && requestURI.endsWith(".json")) {
            return MediaType.APPLICATION_JSON;
        }
        return MediaType.APPLICATION_XML;
    }

    /**
     * Extracts the Base URL from the Request. This method is mainly used to encode other GeoGig
     * Web API request URLs to encode into a Response. For example:
     * <p>
     * <pre>GET http://localhost:8182/repos</pre>
     * <p>
     * would produce a list of currently configured GeoGig repositories. Each repository in the
     * list has a <b>link</b> element in the response that should be a URL to that repository's
     * info details, such as:
     * <p>
     * <pre>http://localhost:8182/repos/repo1.xml</pre>
     * <p>
     * If supplied the above <b>GET</b> request, this method should produce:
     * <p>
     * <pre>http://localhost:8182</pre>
     * <p>
     * <b>NOTE:</b> This method is not reliable in situations where firewalls, proxies, and other
     * redirect mechanisms are in place as the Request that reaches the server may be very different
     * from the request made by the end user.
     *
     * @param request The Request from which to extract the base URL
     *
     * @return A String representation of the GeoGig Web API base URL, from the server perspective.
     */
    protected final String getBaseUrl(HttpServletRequest request) {
        // Extract the baseURL from the request (NOTE: not reliable if proxies are involved)
        final String requestURL = HttpUtils.getRequestURL(request).toString();
        final String requestURI = request.getRequestURI();
        return requestURL.substring(0, requestURL.indexOf(requestURI));
    }

    /**
     * Returns sub-class specific {@link Logger} instance.
     *
     * @return sub-class specific {@link Logger} instance.
     */
    protected abstract Logger getLogger();
}
